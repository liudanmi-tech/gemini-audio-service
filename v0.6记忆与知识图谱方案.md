# v0.6 记忆与知识图谱方案讨论

基于 Mem0 + Graph Store（图数据库），为技能和档案增加记忆能力，用知识图谱呈现精准关系（如：王总 --[讨厌]--> 李总，A项目 --[属于]--> 王总）。

本文档聚焦三个核心问题：**记忆什么时候提取**、**记忆怎么存储**、**记忆怎么调用**。

---

## 1. 当前流程回顾

单次录音分析的主流程（[main.py](main.py)）：

```
上传音频 → Call #1 Gemini 分析 → 写入 analysis_results（transcript、summary、risks）
         → 档案匹配（声纹/占位）→ speaker_mapping、conversation_summary
         → 异步策略生成：场景识别 → 技能匹配 → 技能执行（策略+图片）
```

- **档案**：`profiles` 表，含 name、relationship_type、audio_url 等
- **技能**：`skills` 表，按场景匹配后执行，产出策略与视觉描述

---

## 2. Mem0 与 Graph Memory 简要说明

- **Mem0**：开源记忆层，结合向量嵌入 + 图存储
- **Graph Memory**：从对话中提取实体与关系，存为图节点/边，检索时向量召回 + 图关联补充
- **图存储**：Neo4j、Memgraph、Neptune、Kuzu 等
- **关系示例**：`Person --[讨厌]--> Person`、`Project --[属于]--> Person`

---

## 3. 记忆什么时候提取（When）

### 3.1 推荐时机

| 时机 | 触发点 | 提取内容 | 说明 |
|------|--------|----------|------|
| **A. 分析完成后** | `analyze_audio_async` 写入 analysis_results 之后 | transcript + summary + speaker_mapping | 单录音的主信息源，关系最集中 |
| **B. 档案匹配完成后** | 写入 speaker_mapping、conversation_summary 之后 | 说话人↔档案、谁和谁对话 | 把 Speaker_0/1 换成档案名后再提取，关系更精准 |
| **C. 策略生成完成后** | `_generate_strategies_core` 产出策略后 | 策略文本、视觉描述、技能 id | 包含「谁对谁做了啥」的高层信息 |

### 3.2 推荐策略：**B + C 组合**

- **B（档案匹配后）**：作为**主提取点**  
  - 输入：`conversation_summary` + `transcript`（已用档案名替换 Speaker 标签）  
  - 优点：实体已是档案名（王总、李总），关系更可复用  
  - Mem0 的 `memory.add()` 在此处调用

- **C（策略生成后）**：作为**补充提取点**  
  - 输入：策略文案 + 技能 id  
  - 优点：策略常总结「谁讨厌谁」「谁负责哪个项目」等，适合补充到图谱  
  - 可与 B 同一 `memory.add` 调用，或单独一次（用 `metadata.session_id` 关联）

### 3.3 不推荐或次要的时机

- **A（仅分析完成）**：此时还是 Speaker_0/1，关系与档案脱节，不建议作为主提取点
- **用户手动标注**：可作为未来扩展，本文档先不展开

### 3.4 伪代码示意

```python
# 在 analyze_audio_async 中，speaker_mapping 写入后
if speaker_mapping and conversation_summary:
    memory_payload = build_memory_payload(transcript, conversation_summary, speaker_mapping)
    await memory_layer.add(memory_payload, user_id=user_id, metadata={"session_id": session_id})

# 在 _generate_strategies_core 完成后
for strategy in strategies:
    await memory_layer.add(strategy_text, user_id=user_id, metadata={"session_id": session_id, "skill_id": ...})
```

---

## 4. 记忆怎么存储（How）

### 4.1 双存储结构（Mem0 默认）

| 存储 | 用途 | 示例 |
|------|------|------|
| **向量库** | 语义检索 | Qdrant / pgvector，存 embedding |
| **图库** | 精准关系 | Neo4j / Memgraph，存 Person--[讨厌]-->Person |

### 4.2 与档案、技能的数据关联

- **user_id**：必填，隔离不同用户的记忆
- **metadata**：建议包含  
  - `session_id`：关联录音/任务  
  - `profile_ids`：本对话涉及的档案（来自 speaker_mapping）  
  - `skill_id`：若来自策略，记录技能

### 4.3 关系 schema 设计（需与业务对齐）

建议先定义少量核心关系类型，便于检索和展示：

| 关系类型 | 示例 | 来源 |
|----------|------|------|
| 讨厌/不喜欢 | 王总 --[讨厌]--> 李总 | 策略或对话 |
| 负责/属于 | A项目 --[属于]--> 王总 | 对话 |
| 汇报给 | 李总 --[汇报给]--> 王总 | 对话 |
| 合作 | 王总 --[合作]--> 李总 | 对话 |
| 提及 | 对话 --[提及]--> 某事件 | transcript |

可通过 Mem0 的 `custom_prompt` 约束提取范围，例如：

```
只提取人物与人物、人物与项目之间的明确关系，如：讨厌、负责、汇报给、合作、提及。
人物名使用档案名（如王总、李总），不要使用 Speaker_0/1。
```

### 4.4 图库选型建议

- **Neo4j Aura**：托管、易上手，有免费档
- **Kuzu**：嵌入式，适合本地/小规模，无需独立服务
- **Memgraph**：Docker 部署简单，适合自建

---

## 5. 记忆怎么调用（Recall）

### 5.1 调用时机

| 场景 | 时机 | 调用方式 |
|------|------|----------|
| **策略生成** | 技能执行前 | `memory.search(transcript_summary, user_id)`，将召回的记忆作为 context 注入技能 prompt |
| **档案详情** | 查看某档案时 | `memory.search` 以档案名为关键词，展示该人物相关关系 |
| **任务详情** | 查看某任务时 | 按 session_id 过滤，展示本对话相关记忆（可选） |
| **全局图谱** | 用户主动查看 | 直接查图库，展示人物—关系—人物子图 |

### 5.2 调用方式示例

```python
# 策略生成时：为技能注入记忆
memories = await memory_layer.search(
    query=transcript_summary,
    user_id=user_id,
    limit=5,
    metadata_filter={"profile_ids": {"$in": involved_profile_ids}}
)
context["memory_context"] = "\n".join([m["memory"] for m in memories["results"]])
# 将 context 拼入技能 prompt
```

### 5.3 图谱查询（可选）

若需要「王总讨厌谁」「李总负责什么项目」类查询，可直接走图库：

```cypher
MATCH (a:Person {name: "王总"})-[r:讨厌]->(b) RETURN a, r, b
```

可封装为独立 API，例如 `GET /api/v1/memory/graph?profile_name=王总`。

---

## 6. 实施阶段建议

| 阶段 | 内容 |
|------|------|
| **P0** | 确定「记忆提取」的准确时机（推荐 B+C），在代码中加钩子 |
| **P1** | 接入 Mem0 + 图库（如 Neo4j/Kuzu），实现 add/search |
| **P2** | 策略生成时调用 memory.search，把记忆注入技能 prompt |
| **P3** | 档案/任务详情页展示相关记忆；可选：图谱可视化 API |

---

## 7. 待讨论问题

1. **关系 schema**：是否需要预先枚举所有关系类型，还是先用 Mem0 默认抽取再逐步收敛？
2. **档案名一致性**：图谱中的「王总」如何与 `profiles.name` 对齐？是否需要 id 映射？
3. **记忆更新**：用户纠正关系时，是更新既有记忆还是新增一条？
4. **隐私**：记忆是否按 session 可删除？是否需要「忘记某次对话」能力？

---

## 8. 实施说明（已落地）

- **依赖**：`pip install mem0ai`（Qdrant 本地向量）；可选 `mem0ai[graph]`（Kuzu 图库，需 cmake）
- **存储路径**：`./data/mem0_qdrant`（向量）；有 Kuzu 时 `./data/mem0_graph.kuzu`（图）
- **代码位置**：
  - B 钩子：`main.py` 档案匹配后、策略生成前
  - C 钩子：`main.py` `_generate_strategies_core` 策略+图片完成后
  - 记忆检索：`_generate_strategies_core` 技能执行前
  - 记忆服务：`services/memory_service.py`
  - 技能注入：`skills/executor.py` 支持 `{memory_context}`；`workplace_jungle/SKILL.md` 已加入记忆区块
- **无 mem0ai 时**：记忆功能自动降级，不影响主流程
- **日志**：搜索 `[记忆]` 可查看调用链。B 钩子、C 钩子、search_memory、add_memory、技能注入均有 INFO 级日志

---

## 9. 参考资料

- [Mem0 Graph Memory 文档](https://docs.mem0.ai/open-source/features/graph-memory)
- [Mem0 开源概览](https://docs.mem0.ai/open-source/overview)
- 项目内：[v0.5档案匹配0130.md](v0.5档案匹配0130.md)、[v0.4 技能化架构技术方案设计.md](v0.4%20技能化架构技术方案设计.md)
